// TBD: use html plugins in bundler
function homeDoc() {
  let ht =
  `
  <!DOCTYPE html>
  
  <html>
  <head>
    <style>
      table, th, td {
        border: 1px solid black;
        border-collapse: collapse;
      }
      th, td {
        padding: 5px;
        text-align: left;
      }
      body {
        text-align: left;
      }
      </style>
    </head>
  <body>
  <h1> sasfsp/viyafsedit - A React Component for Building and Viewing Data Entry Forms in SAS Viya </h1>

  <ul>
    <li> <a href="#preamble" > Preamble </a></li>
    <li> <a href="#intro" > Introduction </a></li>
    <li><a href="#features">Key Features</a></li>
    <li> <a href="#usageall"> Using the component in your application </a> </li>
      <ul>
        <li> <a href="#designer">Accessing the Designer</a> </li>
        <li> <a href="#viewform">Displaying a form(runtime</a> </li>
        <li> <a href="#umd"> Example of using script tag</a></li>
      </ul>
    <li> <a href="#components"> Components </a> </li>
    <li> <a href="#newform"> Creating New Form </a> </li>
    <li> <a href="#designform"> Design a form </a> </li>
    <li> <a href="#editvisual"> Customizing visuals </a> </li>
     <ul>
      <li> <a href="#funcsyntax"> Handler Syntax Basics</a> </li>
      <li> <a href="#dataprops"> dataProps</a> </li>
      <li> <a href="#style"> Style </a></li>
      <li> <a href="#eprops"> eProps </a></li>
      <li> <a href="#onedit"> onEdit </a></li>
    </ul>
   <li> <a href="#handlers" > Details on Handlers </a></li>
      <ul>
        <li> <a href="#formula">Handlers using formula syntax</a></li>
        <li> <a href="#jsfunc">Handlers using function syntax</a></li>
        <li> <a href="#builtins"><strong>Builtins</strong> functions to access Viya</strong></a></li>
        <ul>
          <li> <a href="#submitsas"> Executing SAS code </a></li>
          <li> <a href="#submitcasl"> Executing CASL code </a></li>
          <li> <a href="#submitaction"> Executing a CAS Action </a></li>
          <li> <a href="#submitmas"> Scoring using MAS </a></li>
          <li> <a href="#customviya"> Making custom calls to Viya </a></li>
        </ul>
     </ul>
 
  
  </ul>
  <hr>
  <h2 id="preamble"> Preamble </h2>
  <hr>

  At this time this is for internal use only. You can use it to build demos,POC's and internal applications. 
  Do not share the component with customers.

  To install the component see <a href="https://mtesstaticcontent.z13.web.core.windows.net/sasfsp/v1/install.html" target="_blank">this document</a>.

<hr>
  <h2 id="intro">Introduction</h2>
<hr>
  <p>
  sasfsp/viyafsedit is a react component for building and viewing data entry forms.
  It is modeled after the SAS/FSP product from SAS 9. 
  </p>

  <h3> Is it lowcode/nocode</h3>

  I am personally not sure what features make an application lowcode/nocode. 
  
  <p>This version has generic but Viya aware features(components). By adding smarter components for specific domains 
  one could come to close to almost no code for application developers.
  </p>

  <blockquote>
  So for promotional purposes I am claiming sasfsp/viyafsedit is lowcode/nocode :-)
  </blockquote>

  <hr>
  <h2>Key Features</h2>
  <hr>
  <ul>
    <li>The application comes with a set of "smart" components that are Viya aware. The underlying react library is mostly by  
      <a href="https://mui.com/joy-ui/getting-started/overview" target="_blank"> mui/joy </a>. 
      The short term goal is to allow developers to supply their own react components(example: Nova) 
      <ul>
        <li> Add a component to the form with a click</li>
        <li> Resize and move the components with the mouse </li>
        <li> Customize and the look and functionality thru properties. Most properties are scriptable for greater control </li>
      </ul>
       </li>
    <li>The application is built using the SAS Viya REST APIs. </li>
    <li> All client side calculations use Javascript</li>
    <li> Developers have access to all Viya capabilities that are exposed thru REST API.
    <ul>
      <li>The application comes with builtin functions to execute SAS code, CAS code, run cas actions and access MAS</li>
      <li>It also provides a function to make http calls to any other service</li>
    </ul>
    </ul>

  <hr>
  <h2> Installation </h2>
  <hr>

  <p> Anyone within the SAS network, can install it from these locations.
  
  <ul>
  <li> npm install https://mtesstaticcontent.z13.web.core.windows.net/sasfsp/dev/sasfsp-viyafsedit.tgz </li>
  <li> To install it as a script tag in an HTML page use this script tag. The global variable is <strong>viyafsedit</strong>. 
        See this <a href="https://mtesstaticcontent.z13.web.core.windows.net/sasfsp/dev/umd/example.html" target="_blank">example</a> for details</li>
  <pre>
  &lt;script type="text/javascript" src="https://mtesstaticcontent.z13.web.core.windows.net/sasfsp/dev/umd/viyafsedit.js"&gt;&lt;/script&gt;
  </pre>
  </ul>
  <h2 id="usageall"> Using the component in your application </h2>
    
  The component comes with two methods.
  <ul>
    <li> Design - use this method to design, edit and manage data entry forms</li>
    <li> Display - use this to use a form built with the Design method</li>
  </ul>

    I am only documenting the basic props at this time. The component supports
    additiona props(see below). I will document them over the next couple of weeks.

    <ul>
      <li>Pass in an existing cas or compute session</li>
      <li>Pass in userFunctions that can be accessed in the handlers. 
      This will allow reuse of code between applications and simplify the handlers</li>
      <li>Override the library and table associated with a form. This allows one to develop against a dev
        table and switch to production table deployed</li>
    </ul>
  
  <h3 id="designer"> Design</h3>
    In your react application import the component as shown below
    <pre>
        import {Design} from '@sasfsp/viyafsedit';
        return  (&ltDesign
                ViyaConnection={ViyaConnection Object - see below},
                /&gt);
    </pre>
  <h3 id="viewform"> Display</h3>
     Use this method to use a pre-designed form
      <pre>
        import {Display} from '@sasfsp/viyafsedit';  
        return  (&ltDisplay
            ViyaConnection={ViyaConnection Object.See below}
            params: {
              folder=name of the folder where the form is stored
              form=name of the form
            }
            /&gt);
      </pre>
    <p>  

     This method will process the query parmeters of the url and look for overrides of the
     params fields.  This allows one to deploy the app once and use it with different data entry forms.
     </p>
    
  <h3 id="umd"> Using sasfsp/viyafesit via script tag</h3>
  <p> 
    Below are the highlights of invoking the component via script tag.
  </p>
  
  <p>
  [Sidebar: In this example you are basically writing an inline react application.]
  </p>
  
  <br>
  &ltscript src="https://unpkg.com/@babel/standalone/babel.min.js"&gt&lt/script&gt
  
  <br>
  &ltscript crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"&gt&lt/script&gt
  <br>
  
  &ltscript crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"&gt&lt/script&gt
  <br>
  
  
  &ltscript async src="https://cdn.developer.sas.com/packages/va-report-components/dev/dist/umd/va-report-components.js"&gt&lt/script&gt 
  <br> 
  &lt!-- Install @sassoftware/viyafsedit thru the script tag --&gt
  <br>
  &ltscript src="https://mtesstaticcontent.z13.web.core.windows.net/sasfsp/dev/umd/viyafsedit.js"&gt&lt/script&gt 
  <br>
  
  &ltlink rel="stylesheet" href="./App.css"/&gt
  <br>
  <br>
  <br>
  <pre>
    <code lang="javascript">
  &ltscript type="text/babel"&gt
    function _display() {
      
      // The example assumes that you have already authenticated using code authentication
      // Note this setting will also work if you are running the app under VA Web Content
  
      let ViyaConnection = {
          host: "https://your Viya url"  
      }
  
      // Replace params with the folder and form you want to display
      let props = {
        viyaConnection: viyaConnection,
        params: {
          folder: 'Public',
          form: 'MyCoolApp.form'
        }
      }
  
      // Display application(Design or  Display)
  
      const createRoot = ReactDOM.createRoot;
      const container = document.getElementById('container1');
      const root = createRoot(container);
     
      const V = viyafsedit.Display; // replace with viyafsedit.Design for Design 
      root.render(
        &ltV {...props} /&gt
      );
      
    }
    &lt/script&gt
    &ltbody onload="_display()"&gt
      &ltdiv id="container1"&gt &lt/div&gt
  &lt/div&gt
  
   <code>
  </pre>
  <h3 id="viyaconnection"> ViyaConnection Object</h3>
  
     The ViyaConnection object has different schemas based on your authorization method.
     The component also supports implicit flow and password. These two will not be discussed here.
  
  <h4> Authorization_code flow(also works for VA DDC) </h4>
   <pre lang="javascript">
      {
        host    : your Viya host
      }
  </pre>
  
  <h4> With Auth token </h4>
     <pre>
      {
        host    : your Viya host,
        authType: 'server',
        token   : 'your-token-String'
      }
      </pre>
     
  
  
  <hr>
  <h2 id="components" > Components </h2>
  <hr>
  
  The list of components that are available to you are:
  
  <table>
  <tr>
  <th style="width: 20%; text-align: left;"> Name </th>
  <th style="width: 60%;"> Description(mui Component) </th>
  </tr>
  <tr>
  <td>Input</td>
  <td> Input field for numeric values (mui/joy Input)</td >
  </tr>
  <tr>
  <td>Input Text</td>
  <td> Input field for character values(mui/joy Input) </td >
  </tr>
  <tr>
  <td>Input Area</td>
  <td> Multiline Input field for character values(mui/joy Textarea) </td >
  </tr>
  <tr>
  <td>Button</td>
  <td> Button (mui/joy Button)</td >
  </tr>
  <tr>
  <td>CheckBox</td>
  <td> Checkbox (mui/joy Checkbox)</td >
  </tr>
  <tr>
  <td>Radio Box</td>
  <td> This is yet to be implemented(...) </td >
  </tr>
  <tr>
  <td>Dropdown</td>
  <td> A generic dropdown selector(mui/joy Autocomplete)) </td >
  </tr>
  <td>Slider</td>
  <td> A slider (numeric) (mui/joy slider)</td >
  </tr>
  <tr>
  <td>Select Library</td>
  <td> A drop down to select a library(mui/joy Autocomplete)</td >
  </tr>
  <tr>
  <td>Select Table</td>
  <td> A drop down to select a table for a specific library9(mui/joy Autocomplete)</td >
  </tr>
  <tr>
  <td>Select Columns</td>
  <td> A drop down to select columns for a specific library and table. The selections are returned as delimited(user-defined) string((mui/joy Autocomplete)</td >
  </tr>
  <tr>
  <td>Distinct Values</td>
  <td> A drop down that displays distinct values for a specific columns(mui/joy Autocomplete) </td >
  </tr>
  <tr>
  <td>Table Viewer</td>
  <td> View data for a specific library and table(AgGrid) </td >
  </tr>
  <tr>
  <td>Select Report</td>
  <td> Select a report from the list of VA reports(mui/joy Autocomplete) </td >
  </tr>
  <tr>
  <td>Report Viewer</td>
  <td> View a VA report(VA SDK)</td >
  </tr>
  <tr>
  <td>Select Folder</td>
  <td> Select a folder with optional filtering(mui/joy Autocomplete)</td >
  </tr>
  <tr>
  <td>Select File</td>
  <td> Select a file from a folder(with optional filtering)(mui/joy Autocomplete)</td >
  </tr>
  <tr>
  <td>Typography</td>
  <td> A flexible component to display headers, body text etc.(mui/joy Typography)</td>
  </tr>
  <tr>
  <td>HTMLText</td>
  <td> View HTML (useful for ODS output)(div with sanitize)</td >
  </tr>
  </table>
  
  <hr>
  <h2 id="newform">Creating a new form</h2>
  <hr>
  
  Select <strong>New Form</strong> from the menu in the home panel.
  
  <ol> 
   <li> By default the New Form is set up for editing CAS tables. You can switch between CAS tables and SAS tables(compute).</li>
      <ul>
        <li>For SAS tables select the appropriate Compute Context</li>
        <li>For CAS select the cas server</li>
      </ul>
  
   <li>Select a library and a table in that library.</li>
  
   <li>If you want the application to auto update your table as user makes changes to the data set the values for By vars field.</li>

   <li>Select <strong>Design</strong> to start the design.</li> 
    </ol>
  <hr>
  <h2 id="designform">  Design forms </h2>
  <hr>

  <ul>
  <li>By default, all the columns in the table are displayed as text fields. 
    You can drag and resize(if the component allows resizing). 
    Arrange the components to meet your needs.</li>
  
  <li>To add more components to your application select them from the list on the left side of the screen.
     The added component is represented in the current record as a custom column. 
     This means they can referenced in the calculations.</li>
  
  <li>To customize the components select the **Edit Visuals" menu item. 
    The dialog will display a list of all the components. 
    Select a component to edit its properties.
     The details of the properties are explained in the next section.</li>
  
  <li>To view the form in **Test** mode, select the Test button. In this mode the calculations will execute, 
    but you cannot change the form layout or any of the properties.</li>
  
  <li>Do not forget to save the form. Use the **Save** menu item. 
    At this point there is no enforcement of the file extension. Recommend you use .form as the extension.
    </li>
  
  </ul>
  <h2 id="editvisual"> Customizing Visuals</h2>
  
  Select <strong>Edit Visuals</strong> to customize the visuals.Select the component from the list to
  edit the properties. Use the Apply Button to apply all the changes and return to the designer. Select Cancel to ignore all the changes.

  <table>
  <tr>
    <th> property</th>
    <th> Description</th>
  </tr>
  <tr>
    <td> hide</td>
    <td> If checked, the component will not be displayed. If it is component added by user, the component will be deleted</td>
  </tr>
  <tr>
    <td> name</td>
    <td> The name of the component. This is used to reference the component in the calculations. 
      The name of a column from the table cannot be modified. Each component that is added by user has a default name. These can be changed</td>
  </tr>
  <tr>
    <td> type</td>
    <td> The type of the value of the component. In this release this is either double or text. Support for all javascript types are planned. 
        The type of a column cannot be modified. This is determined by the component writer.</td>
  </tr>
  <tr>
    <td> value</td>
    <td> The value of the component in the data object. This can be set in the handlers also. </td>
  </tr>
  <tr>
    <td> label</td>
    <td> The label for the component. This is used in the display</td>
  </tr>
  
  <tr>
    <td> dataProps</td>
    <td> This is a function that returns an object to set other data-related properties. For example, the Select Table component needs to know the value of the data library.
       Similarly the VA SDK needs the values of the Viya Server URL, type of authentication etc...
       <blockquote>
        You can set set the value prop in the dataProps function. 
        This is useful when you want to set the value of a component based on the value of another component. 
        Be aware that setting it here will not change the value in the data object. For that you must change the value in an handler or thru user input
        </blockquote> 
        </td>

  </tr>
  <tr>
    <td> onEdit</td>
    <td> This is a function for the "cell" calculations. This function is executed when the user modifies the value on the form</td>
  </tr>
  <tr>
    <td> style</td>
    <td> This is a function that returns the style for the component. Use logic to assign values. The style object has a special key called eProps that allow the user to set properties(props in react terminology) of the underlying component. 
      This gives the application developer great control over the behavior of the underlying MUI component. 
      As an example, the user can change the orientation of a slider from horizontal to vertical.</td>
  </tr>
    </table>
  

  
  <h3 id="funcsyntax"> Function Syntax- Basics</h3>
  
  The following are passed as arguments to these functions
  
  <pre>
      - data - the current data row object. You can refer to and modify the values using the dot syntax (ex: data.lib)
      - name - name of the component
      - rowIndex - for form editing this value is always 0
      - appEnv - this object has all the control information for the session. The information in this object is useful for more advaned programming. In most scenarios you can ignore this. The key one of interest is the builtins function object. This can be used to submit SAS code, run casl code, run cas actions and run scoring in MAS.
  </pre>
  
  See below for more information on these functions.
  
  <h3 id="dataprops" > dataProps </h3>
  
  Besides the value of the component some components need data dependent values as props.
  For example the Table Selector needs to know the library name. The dataProps for this component is
  show below.
  
  These values are passed as standard props to the underlying component.
  One of the great benefits of the dataProps is that it allows the developer to link components without writing a lot of code(is this what noCode/lowCode is?)
  
  <pre>
  
  {lib: some-expression}
  
  Some samples are:
  
  {lib: 'casuser'}
  
  {lib: data.lib} where lib is the name of another component. This allows for quick linking of components
  
  You can also do more complex calculations and add a return statement
  
  if (name === 'table1) {
    ...some code...
  }
  return {lib: data.lib}
  
</pre>
  
  
  <h2 id="style">Style </h2>
  
  This is also a function that works just like dataProps. The returned object is merged(spread) into the default style of the component.
  
  
 <pre>
  
  Some examples are:
  
  {borderStyle: 'solid}
  
  data.x1 > 100 ? {backgroundColor: 'red'} : {backgroundColor: 'inherit}
  
  if (name === 'table1) {
    ...some code...
  }
  return {backgroundColor: 'red'}
  
</pre>
  
  
  <h3 id="eprops"> eProps</h3>
  
  Many react components have props that are not style, but control the look and feel and behavior of the component. The MUI
  components are no different. 
  
  For example the MUI Slider component has properties like min, max, steps. To give the application developer full access to the very rich set of props, add a special object to style.
  
  <pre>
  
  Some examples:
  
  {backgroundColor: 'grey', eProps: {min: 0, max: 1, steps: 0.1, orientation: 'vertical}}
  
  </pre> 
  
  <h3 id="onedit"> onEdit </h3>
  
  The onEdit is a function that is executed anytime the component is changed by the use. This function is part of the FSEDIT computational model. The flow is shown below
  
  <table>
  <tr>
    <th> Purpose </th>
    <th> SAS/FSP </th>
    <th> viyafsedit </th>
  </tr>
  
  <tr>
    <td> Initialize record on read(per row). Make necessary changes to incoming data, initialize computed column etc.</td>
    <td> INIT label </td>
    <td> init.js </td>
  </tr>
  
  <tr>
    <td> Take actions based on user input(per cell). Useful to do error checking and cross field calculations </td>
    <td> MAIN label </td>
    <td> main.js </td>
  </tr>
  <tr>
    <td> Runs calculations when a particular column cell is modified. Runs before MAIN. This allows developers to isolate column specific calculations and keep MAIN for cross-field updates. Purely a programmer's choice </td>
    <td> {column name} label </td>
    <td> {columnName}.js </td>
  </tr>
  
  <tr>
    <td> Runs before saving the record. A good place to do more advanced management(ex: stream record to REDIS) </td>
    <td> TERM label </td>
    <td> term.js </td>
  </tr>
  
  </table>
  
  
  <h2 id="handlers"> Details on handlers </h2>
  This section is a more detailed explanation of handlers.
  
  <h3 id="formula">Handlers using formula syntax</h3>
  
  If your calculations can be written with single Javascript expression use the suntax shown
  below
  
  <pre>
    {
        init: (data, rowIndex, appEnv) => data.total = data.x1 + data.x2 + data.x3,
        main: (data, rowIndex, appEnv) => data.total = data.x1 + data.x2 + data.x3,
        term: (data, rowIndex, appEnv) => data,
        x2: (data, name, rowIndex, appEnv) => data.x2 > 500 ? 500 : data.x2
    }
  </pre>
  
  
  <h3 id="jsfunc">Handlers using function syntax</h3>
  
  Some or all the handlers can be written using standard Javascript function syntax. This form is useful if the handler is complex(like calling Viya using REST API)
  
  Below is an example of the handlers.
  
  <pre>
   {
      appInit: async (appEnv) => { 
        /* do your app initialization here */
        return {statusCode: 0, msg: 'appInit processing completed'};
      },
  
      init: async (data, rowIndex, appEnv) => {
        data.total = data.x1 + data.x2 + data.x3;
        return data;
      },
  
      main: async (data, rowIndex, appEnv) => {
        data.total = data.x1 + data.x2 + data.x3,
        return data;
      },
      
      term: async (data, rowIndex, appEnv) => {
        /* this is run before the row is persisted */
        return data;
      }
  
      x2: async (data, name, rowIndex, appEnv) => {
        if (data.x2 > 500) {
          data.x2 = 500;
        }
        return data;
      }
  
    }
    
  </pre>

  The primary purpose of the builtins object is to allow the developer to access Viya from the application. The builtins object has the following functions
  The functions can be accessed as appEnv.builtin.<function name>

  <hr>
  <h4 id="submitsas"> Executing SAS code  </h4>
  <hr>

  The submit function (appEnv.builtins.submit) is used to submit SAS code to the compute server. 
  The syntax is:

  <pre>
   await appEnv.builtins.submit(src, macros, output,appEnv);
  </pre>

  In this release, this function can only be used if the table being edited is a SAS table. The function will use the same compute session.
  This restrictions will be removed in a future release.

  This function simplfies the submission of SAS code to the compute server and 
  retrieval of the results. The function takes the following parameters
  <pre>
    src - the source code to be submitted
    macros - an object containing the macro variables(ex: {x: 1, y: 2}). These are prepended to the code as macro variables
    output - an object that specifies the desired ouput. This is an object of the form
    {
      ods: true/false, /* if true, the ODS output is returned in the results */
      log: true/false, /* if true, the log is returned in the results */  
      listing: true/false, /* if true, the listing is returned in the results */
      tables: Tables to be returned. 
    }
    appEnv - the application environment
  </pre>
  
  The contents of the returned object determined by the output parameter. The output will have an key for each key specified
  in the output parameter. The contents of the key is the output from the SAS code. The output is returned as a string.


  <pre>
    {
      status: {
        statusCode: 0/1, /* 0 means success, 1 means warnings, 2 means errors */
        msg: 'error message if any'
      },
      results: {
        ods: 'ods output',
        log: 'log output',
        listing: 'listing output',
        tables: {
          table1: { /* info on table1 */ },
          table2: { /* info on table2 */ }
        }
      }
    }
  </pre>

  A sample usage is shown below
  <pre>



  </pre>

 
  <h3 id="submitcasl"> Executing CASL code  </h3>
  The submitCasl function (appEnv.builtins.submitCasl) is used to submit CASL code to the CAS server
  The syntax is:
  <pre>
    let output = await appEnv.builtins.submitCasl(src, args, appEnv);
    </pre>

  The parameters are
  <pre>
    src - the source code to be submitted
    args - an object containing the arguments to the CASL code. 
    This javascript object is converted to a CASL dictionary with the name _args_. It
    is prepended to the code as a dictionary
    appEnv - the application environment
  </pre>
  The casl program must return results using the following syntax:
  <pre>
    send_response(_{casResults =<your results>});
  </pre>

  The output is an object of the form
  <pre
  let output = {status, results};
  </pre>
  The results in the output is what ever specified for casResults above.
  
  Here is trivial example of a CASL program that echos the _args_ dictionary

  <pre>
    let args = {x:1, y:2}; 
    let src = \`send_response({casResults=_args_});\`;
    let {status, results} = await appEnv.builtins.submitCasl(src, args, appEnv);
    console.log(status);
    console.log(results);
    /* do someting with the results */
    return data;
  </pre>

  <h3 id="submitaction"> Executing a CAS Action </h3>
  The submitAction function (appEnv.builtins.submitAction) is used to submit a CAS action to the CAS server. This function is useful
  to run a single CAS action. If you need to run multiple CAS actions or want to control the output to client, I recommend running submitCasl instead.

  The syntax is:
  <pre>
    await appEnv.builtins.submitAction(action, params, appEnv);
  </pre>
  The syntax is:
  <pre>
  action - name of the action(recommend actionset.action as the name)
  params - an object containing the parameters to the action.
  appEnv - the application environment
  </pre>
  The parameters are whatever the action requires. The output is an object that is determined by the action writer.
  An example is shown below
  
  <pre>
    let params = {
      single: 'YES',
      code:
          'data casuser.score; keep x1 x2;do i = 1 to 20; x1=i; x2=i*10;output;end;run; '
  };
  let { status, results } = await appEnv.builtins.submitAction('datastep.runCode', params, appEnv);
  if (status.statusCode > 0) {
      return ({ status, data });
  } else {
      data.table = 'casuser.score';
      console.log(results);
      return data;
  }

  </pre>
  
  <h3 id="submitmas"> Scoring using MAS </h3>
  The submitMAS function (appEnv.builtins.submitMAS) is used to score using MAS. 
  The syntax is:
  <pre>
  modelName - name of the model
  data - data to be scored( the function will pass the proper subset to MAS)
  appEnv - the application environment
  inputSyntax - true/false. If true, the data is passed CAs in the old style.
  </pre>

  The output is an object with the following syntax

  <pre>
  { status: {statusCode: 0/1/2, msg: 'error message if any'},
    results: { /* results from MAS */ }
    </pre>

  Below is a sample usage
  <pre>
    score: async (data, name, row, appEnv) => {
      let output = await appEnv.builtins.masScoring('mfgCMP1_0', data, appEnv, true);
      let { status, results } = output;
      if (status.statusCode === 2) {
        data.command = "Failed to score";
      } else {
        data.quality = results.QUALITY;
        data.prob = results.P_FAILURE1.toFixed(2) * 1.0;
        data.command = results.INSTR;
      };
      return data;
    }
  </pre>
  <h3 id="customviya"> Making custom calls to Viya </h3>
  The access to Viya is not limited to the builtins. You can add your own calls to Viya. Use the information in appEnv.
  The appEnv object contains the following information that can be used to make calls to Viya. 
  
  <ul>
    <li> viyaConnection: this is the information you passed to the component. 
         Use this to make your own http calls. Use the builtin function <strong>request</strong> to make those calls.
         The request function is a simple wrapper around Axios.js. See <a href="https://axios-http.com/docs/intro"> Axios.js</a> for documentation on Axios
    </li>
    <li> store: sasfsp/viyafsedit uses <a href="https://sassoftware.github.io/restaf"> @sassoftware/restaf and @sassoftware/restaflib</a>
       to make the REST calls to Viya. The store object is the control object for those calls. See documentation for more information.
     </li>
    <li> userFunctions: Use the useFunctions parameter to hold your "custom" access methods to SAS/Viya</li>
  </ul>
</h4>

  </body>
  </html>
  `;
  return ht;
}
export default homeDoc;
